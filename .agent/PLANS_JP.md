# AIエージェント実行計画書（ExecPlans）:

このドキュメントは、実行計画書（「ExecPlan」）の要件を説明します。実行計画書とは、コーディングエージェントが機能やシステム変更を実装するために従うことができる設計文書です。読者はこのリポジトリの完全な初心者として扱ってください。読者が持っているのは現在の作業ツリーと、あなたが提供する単一のExecPlanファイルだけです。以前の計画の記憶も外部コンテキストもありません。

## ExecPlansとPLANS.mdの使用方法

実行可能仕様書（ExecPlan）を作成する際は、PLANS.mdに*文字通り*従ってください。コンテキストにない場合は、PLANS.mdファイル全体を読んで記憶を更新してください。正確な仕様書を作成するために、ソース資料を徹底的に読み（再読して）ください。仕様書を作成する際は、骨組みから始めて、調査しながら詳細を埋めていきます。

実行可能仕様書（ExecPlan）を実装する際は、「次のステップ」をユーザーに尋ねないでください。単純に次のマイルストーンに進んでください。すべてのセクションを最新の状態に保ち、停止ポイントごとにリスト内のエントリを追加または分割して、達成された進捗と次のステップを明確に述べます。曖昧さは自律的に解決し、頻繁にコミットしてください。

実行可能仕様書（ExecPlan）について議論する際は、仕様書内のログに決定事項を記録して後世に残してください。仕様書への変更がなぜ行われたのかは明確でなければなりません。ExecPlansは生きたドキュメントであり、*ExecPlanのみ*から、他の作業なしに常に再開できるようにする必要があります。

困難な要件や重大な未知数を伴う設計を調査する際は、マイルストーンを使用して概念実証や「おもちゃの実装」などを実装し、ユーザーの提案が実行可能かどうかを検証します。ライブラリを見つけたり取得したりしてソースコードを読み、深く調査し、より完全な実装を導くためのプロトタイプを含めてください。

## 要件

譲れない要件：

* すべてのExecPlanは完全に自己完結していなければなりません。自己完結とは、現在の形式で初心者が成功するために必要なすべての知識と指示が含まれていることを意味します。
* すべてのExecPlanは生きたドキュメントです。貢献者は、進捗が進むにつれて、発見があるにつれて、設計決定が確定するにつれて、それを修正する必要があります。各修正は完全に自己完結したままでなければなりません。
* すべてのExecPlanは、このリポジトリの事前知識なしに、完全な初心者が機能をエンドツーエンドで実装できるようにしなければなりません。
* すべてのExecPlanは、単に「定義を満たす」コード変更ではなく、実証可能に動作する振る舞いを生成しなければなりません。
* すべてのExecPlanは、技術用語をすべて平易な言葉で定義するか、使用しないでください。

目的と意図が最優先です。まず、なぜこの作業がユーザーの観点から重要なのかを数文で説明します。この変更後に誰かができるようになること、以前はできなかったこと、そしてそれが動作していることをどのように確認できるかです。次に、その結果を達成するための正確な手順を読者に案内します。何を編集し、何を実行し、何を観察すべきかを含めます。

あなたの計画を実行するエージェントは、ファイルのリスト表示、ファイルの読み取り、検索、プロジェクトの実行、テストの実行ができます。事前のコンテキストを知らず、以前のマイルストーンからあなたが意図したことを推測できません。依存する仮定はすべて繰り返してください。外部のブログやドキュメントを指さないでください。知識が必要な場合は、自分の言葉で計画自体に埋め込んでください。ExecPlanが以前のExecPlanに基づいており、そのファイルがチェックインされている場合は、参照により組み込んでください。そうでない場合は、その計画からの関連するすべてのコンテキストを含める必要があります。

## フォーマット

フォーマットとエンベロープはシンプルで厳密です。各ExecPlanは、三重バッククォートで始まり終わる、`md`とラベル付けされた単一のフェンスコードブロックでなければなりません。内部に追加の三重バッククォートコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、またはコードを示す必要がある場合は、その単一のフェンス内でインデントされたブロックとして提示します。ExecPlanのコードフェンスを早期に閉じないように、ExecPlan内部でコードフェンスではなくインデントを使用して明確性を保ちます。すべての見出しの後に2つの改行を使用し、#、##などを使用し、順序付きリストと順序なしリストの正しい構文を使用します。

ExecPlanの内容*のみ*がMarkdown（.md）ファイルに書き込まれる場合、三重バッククォートは省略する必要があります。

平易な散文で書いてください。リストよりも文を好みます。簡潔さが意味を曖昧にする場合を除き、チェックリスト、表、長い列挙を避けてください。チェックリストは`Progress`セクションでのみ許可され、そこでは必須です。物語セクションは散文を優先したままでなければなりません。

## ガイドライン

自己完結性と平易な言葉が最も重要です。通常の英語ではないフレーズ（「デーモン」、「ミドルウェア」、「RPCゲートウェイ」、「フィルターグラフ」）を導入する場合は、すぐに定義し、このリポジトリでそれがどのように現れるかを読者に思い出させてください（たとえば、それが表示されるファイルやコマンドの名前を挙げることによって）。「前に定義したとおり」や「アーキテクチャドキュメントによれば」と言わないでください。ここに必要な説明を含めてください。自分自身を繰り返しても構いません。

よくある失敗モードを避けてください。未定義の専門用語に頼らないでください。結果のコードがコンパイルされても意味のあることを何もしないほど狭く「機能の文字通り」を説明しないでください。重要な決定を読者に外注しないでください。曖昧さが存在する場合は、計画自体でそれを解決し、なぜそのパスを選択したかを説明します。ユーザーに見える効果を過剰に説明し、付随的な実装の詳細を過小に指定する側に誤ってください。

観察可能な結果で計画を固定します。実装後にユーザーができること、実行するコマンド、見るべき出力を述べます。受け入れは、内部属性（「HealthCheck構造体を追加した」）ではなく、人間が検証できる振る舞い（「サーバーを起動した後、[http://localhost:8080/health](http://localhost:8080/health)に移動すると、本文OKでHTTP 200が返される」）としてフレーズ化する必要があります。変更が内部的なものである場合、その影響がどのように実証できるかを説明します（たとえば、変更前に失敗し変更後に成功するテストを実行し、新しい振る舞いを使用するシナリオを示すことによって）。

リポジトリのコンテキストを明示的に指定します。完全なリポジトリ相対パスでファイルに名前を付け、関数とモジュールを正確に名前を付け、新しいファイルを作成する場所を説明します。複数の領域に触れる場合は、初心者が自信を持ってナビゲートできるように、それらの部分がどのように組み合わさるかを説明する短いオリエンテーション段落を含めます。コマンドを実行する場合は、作業ディレクトリと正確なコマンドラインを示します。結果が環境に依存する場合は、仮定を述べ、合理的な場合は代替案を提供します。

べき等で安全にします。損傷やドリフトを引き起こすことなく複数回実行できるようにステップを書きます。ステップが途中で失敗する可能性がある場合は、再試行または適応する方法を含めます。マイグレーションまたは破壊的操作が必要な場合は、バックアップまたは安全なフォールバックを詳しく説明します。進むにつれて検証できる、追加的でテスト可能な変更を好みます。

検証はオプションではありません。テストを実行し、該当する場合はシステムを起動し、何か有用なことをしているのを観察する指示を含めます。新しい機能や能力の包括的なテストを説明します。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めます。可能な限り、コンパイルを超えて変更が効果的であることを証明する方法を示します（たとえば、小さなエンドツーエンドのシナリオ、CLI呼び出し、またはHTTPリクエスト/レスポンストランスクリプトを通じて）。プロジェクトのツールチェーンに適した正確なテストコマンドと、その結果の解釈方法を述べます。

証拠を収集します。ステップがターミナル出力、短い差分、またはログを生成する場合は、単一のフェンスブロック内にインデントされた例として含めます。それらを簡潔に保ち、成功を証明するものに焦点を当てます。パッチを含める必要がある場合は、大きなブロブを貼り付けるのではなく、読者があなたの指示に従って再作成できるファイルスコープの差分または小さな抜粋を好みます。

## マイルストーン

マイルストーンは物語であり、官僚主義ではありません。作業をマイルストーンに分割する場合は、範囲、マイルストーンの終わりに存在する以前は存在しなかったもの、実行するコマンド、観察することを期待する受け入れを説明する簡単な段落で各マイルストーンを紹介します。ストーリーとして読みやすく保ちます：目標、作業、結果、証明。進捗とマイルストーンは別物です。マイルストーンはストーリーを語り、進捗は細かい作業を追跡します。両方とも存在しなければなりません。簡潔さのためだけにマイルストーンを省略しないでください。将来の実装に重要な可能性のある詳細を省略しないでください。

各マイルストーンは独立して検証可能であり、実行計画の全体的な目標を段階的に実装する必要があります。

## 生きた計画と設計決定

* ExecPlansは生きたドキュメントです。重要な設計決定を行うときは、決定とその背後にある考えの両方を記録するために計画を更新します。すべての決定を`Decision Log`セクションに記録します。
* ExecPlansには、`Progress`セクション、`Surprises & Discoveries`セクション、`Decision Log`、および`Outcomes & Retrospective`セクションが含まれ、維持されなければなりません。これらはオプションではありません。
* オプティマイザーの動作、パフォーマンスのトレードオフ、予期しないバグ、またはアプローチを形作った逆/適用解除のセマンティクスを発見した場合は、短い証拠スニペット（テスト出力が理想的）とともに、それらの観察を`Surprises & Discoveries`セクションに記録します。
* 実装の途中でコースを変更する場合は、`Decision Log`でその理由を文書化し、`Progress`に影響を反映させます。計画は、あなたのためのチェックリストであると同時に、次の貢献者のためのガイドです。
* 主要なタスクまたは完全な計画の完了時に、達成されたこと、残っていること、学んだ教訓を要約する`Outcomes & Retrospective`エントリを書きます。

# プロトタイピングマイルストーンと並行実装

より大きな変更のリスクを軽減する場合、明示的なプロトタイピングマイルストーンを含めることは許容されます—そしてしばしば推奨されます。例：実現可能性を検証するために依存関係に低レベルの演算子を追加する、またはオプティマイザーの効果を測定しながら2つの構成順序を探索する。プロトタイプを追加的でテスト可能に保ちます。範囲を「プロトタイピング」として明確にラベル付けします。実行して結果を観察する方法を説明します。プロトタイプを昇格または破棄するための基準を述べます。

テストが合格し続ける追加的なコード変更の後に減算を行うことを好みます。並行実装（たとえば、大規模な移行中に古いパスと一緒にアダプターを保持する）は、リスクを減らしたり、大規模な移行中にテストが合格し続けることを可能にしたりする場合には問題ありません。両方のパスを検証する方法と、テストで安全に1つを廃止する方法を説明します。複数の新しいライブラリまたは機能領域を扱う場合、これらの機能の実現可能性を*互いに独立して*評価するスパイクを作成し、外部ライブラリが期待どおりに動作し、必要な機能を分離して実装することを証明することを検討してください。

## 良いExecPlanの骨組み

```md
# <短く、行動指向の説明>

このExecPlanは生きたドキュメントです。`Progress`、`Surprises & Discoveries`、`Decision Log`、および`Outcomes & Retrospective`セクションは、作業が進むにつれて最新の状態に保たれなければなりません。

PLANS.mdファイルがリポジトリにチェックインされている場合は、リポジトリルートからそのファイルへのパスをここで参照し、このドキュメントがPLANS.mdに従って維持されなければならないことを記します。

## Purpose / Big Picture（目的/全体像）

この変更後に誰かが得るものと、それが動作していることをどのように確認できるかを数文で説明します。有効にするユーザーに見える振る舞いを述べます。

## Progress（進捗）

チェックボックス付きのリストを使用して、細かいステップを要約します。すべての停止ポイントをここに文書化する必要があります。部分的に完了したタスクを2つ（「完了」対「残り」）に分割する必要がある場合でもです。このセクションは常に作業の実際の現在の状態を反映しなければなりません。

- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了：X; 残り：Y）。

進捗の速度を測定するためにタイムスタンプを使用します。

## Surprises & Discoveries（驚きと発見）

実装中に発見された予期しない動作、バグ、最適化、または洞察を文書化します。簡潔な証拠を提供します。

- 観察：…
  証拠：…

## Decision Log（決定ログ）

計画に取り組んでいる間に行われたすべての決定を次の形式で記録します。

- 決定：…
  根拠：…
  日付/著者：…

## Outcomes & Retrospective（結果と振り返り）

主要なマイルストーンまたは完了時に、結果、ギャップ、学んだ教訓を要約します。結果を元の目的と比較します。

## Context and Orientation（コンテキストと方向付け）

読者が何も知らないかのように、このタスクに関連する現在の状態を説明します。完全なパスで主要なファイルとモジュールに名前を付けます。使用する自明でない用語を定義します。以前の計画を参照しないでください。

## Plan of Work（作業計画）

編集と追加のシーケンスを散文で説明します。各編集について、ファイルと場所（関数、モジュール）、挿入または変更する内容に名前を付けます。具体的で最小限に保ちます。

## Concrete Steps（具体的なステップ）

実行する正確なコマンドとそれらを実行する場所（作業ディレクトリ）を述べます。コマンドが出力を生成する場合、読者が比較できるように短い期待されるトランスクリプトを示します。このセクションは作業が進むにつれて更新されなければなりません。

## Validation and Acceptance（検証と受け入れ）

システムを起動または実行する方法と観察すべきことを説明します。受け入れを、特定の入力と出力を伴う振る舞いとしてフレーズ化します。テストが含まれる場合は、「<プロジェクトのテストコマンド>を実行し、<N>件合格することを期待します。新しいテスト<名前>は変更前に失敗し、変更後に成功します」と言います。

## Idempotence and Recovery（べき等性と回復）

ステップが安全に繰り返すことができる場合は、そう言います。ステップがリスクを伴う場合は、安全な再試行またはロールバックパスを提供します。完了後に環境をクリーンに保ちます。

## Artifacts and Notes（成果物とメモ）

最も重要なトランスクリプト、差分、またはスニペットをインデントされた例として含めます。それらを簡潔に保ち、成功を証明するものに焦点を当てます。

## Interfaces and Dependencies（インターフェースと依存関係）

規範的であってください。使用するライブラリ、モジュール、サービスに名前を付け、その理由を述べます。マイルストーンの終わりに存在しなければならない型、トレイト/インターフェース、および関数シグネチャを指定します。`crate::module::function`や`package.submodule.Interface`などの安定した名前とパスを好みます。例：

crates/foo/planner.rsで定義：

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```

上記のガイダンスに従えば、単一のステートレスなエージェント—または人間の初心者—があなたのExecPlanを上から下まで読んで、動作する観察可能な結果を生成できます。それが基準です：自己完結、自己充足、初心者を導く、結果重視。

計画を修正する場合、生きたドキュメントセクションを含むすべてのセクションに変更が包括的に反映されていることを確認し、計画の最後に変更とその理由を説明するメモを書く必要があります。ExecPlansは何をするかだけでなく、ほぼすべてのことについてなぜそうするかを説明しなければなりません。